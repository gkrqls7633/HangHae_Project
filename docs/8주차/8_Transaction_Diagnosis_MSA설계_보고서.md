# Transaction Diagnosis : MSA 구조 설계 보고서

## 목차
[1. 배경](#1-배경)

[2. 문제 해결](#2-문제-해결)

[3. 결론](#3-결론)


# ✏️ 1. 배경

서비스의 규모가 커짐에 따라 하나의 애플리케이션에서 모든 기능을 처리하는 것이 점점 비효율적으로 변하게 된다.
코드베이스가 커지고, 배포가 느려지며, 작은 변경 하나에도 전체 시스템이 영향을 받는데,
이를 해결하기 위해 **업무 도메인별로 기능을 나누고, 각 기능을 독립된 서비스로 분리**하여 개발과 운영의 효율성을 높이고자 MSA를 도입한다.
MSA는 각 도메인을 **작고 독립적인 단위의 마이크로서비스로 나누어**, 유지보수성과 확장성, 배포의 유연성을 확보하는 것이 핵심이다.

## 📌1.1 Monolithic vs MSA 구조 비교

[monolothic_msa_비교](monolothic_msa_비교.png)

- Monolithic Architecture
  - 전통의 아키텍처를 지칭한다.
  - 소프트웨어의 모든 구성요소가 한 프로젝트에 통합 되어 있는 형태이며,
  - 모놀리식 아키텍처의 경우 모든 프로세스가 긴밀하게 결합되고 단일 서비스로 실행된다.
  - 애플리케이션의 한 프로세스에 대한 수요가 급증하면 해당 아키텍처 전체를 확장해야 한다.
- Microservice Architecture
  - 하나의 애플리케이션을 **작고 독립적으로 배포 가능한 서비스들의 집합**으로 구성하는 소프트웨어 아키텍처 스타일이다.
  - 기능별로 서비스를 나누어 독립적으로 개발, 배포, 확장할 수 있다.

---

# ✏️ 2. 문제 해결

## 📌2-1. 도메인 분리 및 설계

[콘서트서비스_MSA구조.png](콘서트서비스_MSA구조.png)

콘서트 예약 시스템은 다음과 같은 핵심 도메인으로 구성되어 있다.(Monolithic)

- `user` (회원)
- `concert` (공연 정보)
- `seat` (좌석 정보)
- `booking` (좌석 예약)
- `payment` (결제)
- `point` (포인트)
- `queue` (예약 대기열)

이 도메인들을 다음과 같이 마이크로서비스 단위로 분리한다.(MSA)

| 마이크로서비스 | 포함 도메인 | 책임 및 설명 |
| --- | --- | --- |
| **User Service** | `user`, `point` | 사용자 등록, 인증, 프로필 관리, 포인트 적립/차감/이력 관리 |
| **Concert Service** | `concert`, `seat` | 콘서트 정보 등록, 수정, 조회 / 좌석 구조 및 상태 관리 |
| **Booking Service** | `booking`, `queue` | 예약 처리, 좌석 점유, 대기열 관리 |
| **Payment Service** | `payment` | 결제 처리, 외부 PG 연동, 환불 등 |

## 📌2-2. MSA 코드 변경 샘플

- AS-IS : Monolothic 구조
```java
// 1. Concert 정보 조회
Concert concertInfo = concertRepository.findById(...);

// 2. Point 조회 및 차감 가능 여부 체크
Point point = pointRepository.findById(...);
if (!point.isEnough(...)) { ... }

// 3. 결제 상태 변경
payment.changeStatus(COMPLETED);
paymentRepository.save(...);

// 4. 여러 도메인 이벤트 발행
publish(new UserPointUsedEvent(...));
publish(new SeatBookedCompletedEvent(...));
publish(new ExternalDataSaveEvent(...));

```

- TO-BE : MSA 구조
```java
// 1. Concert 정보 API 호출
ConcertResponse concertInfo = concertClient.getConcertInfo(booking.getConcertId());

// 2. 유저 포인트 체크 API 호출
boolean pointAvailable = userClient.isPointEnough(userId, concertInfo.getPrice());
if (!pointAvailable) {
    paymentClient.updateStatus(paymentId, FAILED);
    throw new PaymentException("잔액을 확인해주세요.");
}

// 3. 결제 완료 처리
paymentClient.updateStatus(paymentId, COMPLETED);

// 4. 이벤트 발행 → 비동기 메시지 기반
eventPublisher.publish(new UserPointUsedEvent(userId, concertInfo.getPrice()));
eventPublisher.publish(new SeatBookedCompletedEvent(seatId));
eventPublisher.publish(new ExternalDataSaveEvent(paymentId));

```

<변경 사항>
- 내부 DB 접근 -> concertService REST 호출, userService API 호출 또는 메시지 처리
- 트랜잭션 내 직접 저장 -> paymentService에 상태 변경 요청
- 내부 클래스 직접 호출 -> Kafka 등 메시지 브로커에 publish


## 📌2-3. 서비스 분리 기준 및 사례

| 분리 기준 | 설명 | 적용 사례                                                                                                    |
| --- | --- |----------------------------------------------------------------------------------------------------------|
| ✅ **응집도 기준** | 동일한 책임과 로직을 공유하는 도메인은 하나의 서비스에 통합하여 응집도를 높임 | - 예약 + 대기열 → **Booking Service** <br>- 콘서트 + 좌석 → **Concert Service** <br> - 회원 + 포인트 → **User Service** |
  | ✅ **결합도 최소화** | 외부 연동이나 변경 가능성이 높은 도메인은 별도 분리하여 영향도 최소화 | - 결제 → **Payment Service**로 분리 <br>- 포인트는 사용자와 밀접하므로 **User Service**에 포함                                    |
  | ✅ **독립 배포 가능성** | 변경 주기와 기능 복잡도를 고려하여 독립적으로 배포 가능한 구조로 분리 | - User, Concert, Payment는 **개별 배포 가능** <br>- Booking은 **핵심 흐름에 집중**되므로 별도 유지                                 |
  | ✅ **고가용성 고려** | 부하가 집중되는 영역은 병목 방지와 장애 대응을 위해 분리하여 수평 확장 가능하게 설계 | - Booking, Payment, Queue는 **독립 서비스로 구성** <br>→ Redis, 메시지큐 등으로 확장성 확보 가능                                    |

## 📌 2-4. 배포 단위로서의 적절성 판단

마이크로서비스로의 도메인 분리는 단순히 기능을 나누는 것을 넘어서, 각 서비스가 독립적으로 배포되고, 운영될 수 있는 수준의 경계(경계 컨텍스트)로 나뉘어야 한다.

이를 판단하기 위해 다음과 같은 기준을 고려한다.

| 항목 | 설명 | 적용 사례 및 효과                                                                                                                                                                                                                                                                                                                                                       |
| --- | --- |------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ✅ **도메인 간 책임 분리 명확성** | 각 서비스는 자신이 책임지는 도메인 외의 데이터에 접근하지 않고, 필요한 경우 명확한 인터페이스(API, 이벤트)를 통해 통신함 | - `User`는 사용자/포인트만 관리, 결제/예약 상태는 관여하지 않음<br> - `Booking`은 좌석 점유 결정 시 `Seat`의 데이터 조회만 활용 <br>- `Payment`는 외부 결제 요청만 처리, 내부 예약 상태는 모름 <br>→ **단일 책임 원칙(SRP)** 충실                                                                                                                                                                                                   |
  | ✅ **변경 독립성** | 각 서비스는 다른 서비스의 변경 없이 독립적으로 수정 및 배포 가능 | - 포인트 정책 변경 시 `User Service`만 배포 <br> - PG 연동 변경 시 `Payment Service`만 수정 <br>- 좌석 구조 변경 시 `Concert Service`만 영향<br> → **변경 파급 최소화**, CI/CD 용이    |
  | ✅ **확장성과 부하 분산 고려** | 부하 특성에 따라 분리하여 병목 해소와 수평 확장이 가능하도록 구성 | - `Booking`, `Queue` → 높은 트래픽 대비용 수평 확장<br> - `Payment` → 실패 대비 비동기 처리 및 Retry 적용 <br> - `User`, `Concert` → 읽기 최적화 및 캐시 활용  <br> → 서비스별 성능 튜닝 가능 |
  | ✅ **보안 및 권한 관리** | 서비스별로 인증/인가 정책을 별도로 구성하여 보안 체계 강화 | - `User Service` → 개인정보 보호, 인증 토큰 처리  <br>- `Payment Service` → 외부 연동 보안 강화 <br>- `Concert Service` → 관리자만 접근 가능 (RBAC) <br>→ 감사 로그/접근 제어 강화 가능                                                                                        |
  | ✅ **테스트 및 장애 격리 용이성** | 서비스 단위 테스트 가능하며, 장애 발생 시 전체 시스템 영향 없이 부분 대응 가능 | - `PG 장애` 발생 시에도 `Booking`은 큐에 저장하고 재시도  <br> - `Concert Service` 점검 시에도 예약/결제는 정상 운영 <br>  → **문제 서비스만 롤백 가능**, **테스트 자동화 용이** |

## 📌 2.5. 트랜잭션 분리에 따른 문제와 해결 방안

MSA 구조에서는 각 서비스가 독립된 DB를 가지므로, 기존 모놀리식 시스템에서 제공되던 **ACID 트랜잭션의 보장이 어렵다**. 하나의 유저 요청이 여러 서비스에 걸쳐 처리되면, 그 흐름 중 일부가 실패해도 전체를 롤백하는 것이 불가능해지며, 이로 인해 다음과 같은 문제가 발생할 수 있다.

**✔2.5.1. 원자성(Atomicity) 문제**

- 여러 서비스가 연쇄적으로 트랜잭션을 수행할 경우, **중간 단계 실패 시 전체를 원자적으로 롤백하는 것이 어려울 수 있다.**
- 예를 들어, 사용자가 콘서트 좌석을 예약하고 결제를 진행했는데, 마지막 포인트 차감에서 실패하면 이미 결제된 금액을 자동으로 취소할 수 없다.

➡️  **SAGA 패턴 고려**
SAGA는 각 단계가 성공적으로 완료될 때 다음 서비스로 진행하며, 어느 한 단계에서 실패할 경우 **보상 트랜잭션(Compensating Transaction)**을 통해 이전 단계를 되돌린다.
→ ex) 포인트 차감 실패 시 결제 취소 요청을 보내고, 좌석 점유도 해제하는 방식

**✔2.5.2. 데이터 정합성 문제**
- 서비스 간 데이터 반영이 비동기 또는 느슨한 연결로 이루어질 경우, 일시적인 불일치(Inconsistency)가 발생할 수 있다.
- 예를 들어, 예약은 완료됐지만 포인트 적립이 되지 않거나, 결제는 성공했지만 예약 확정이 안 된 상태가 존재할 수 있다.

➡️ **Eventually Consistent Architecture 고려**
Kafka 같은 메시지 브로커를 사용하여 이벤트 기반으로 데이터를 전달하고, 소비자 서비스가 이를 처리함으로써 정합성을 **시간 차를 두고 보장한다.**
또한 실패 이벤트에 대한 재처리(재시도), Dead Letter Queue 처리 등을 통해 안정성을 확보한다.

**✔2.5.3. 중복 요청 처리**
- 서비스가 중단되었거나 네트워크 오류가 발생한 경우, 클라이언트가 **동일 요청을 여러 번 전송할 수 있다.**
- 특히, 결제나 포인트 차감과 같은 요청은 중복 처리가 큰 문제가 될 수 있다.

➡️  **Idempotency Key** 사용 (멱등성 키)
각 요청에 대해 고유한 키를 발급하고, 같은 키로 들어오는 요청은 **한 번만 처리**되도록 서버 측에서 보장합니다.

**✔2.5.4. 장애 추적 어려움**
- 여러 서비스가 순차적으로 호출되기 때문에, 사용자 요청 처리 중 어느 서비스에서 오류가 발생했는지 확인하기 어렵다.

➡️ **분산 트레이싱(Distributed Tracing)** 도구 도입
ez) Zipkin, Jaeger, OpenTelemetry

**✔2.5.5. 일관된 응답 제공의 어려움**
- 여러 서비스가 순차적으로 호출될 경우, 실패 지점이나 시간 차이로 인해 사용자에게 **불완전하거나 애매한 응답이 전달될 수 있다.**
- 예를 들어, 결제는 성공했지만 좌석 점유에 실패하면 사용자는 결제만 된 상태에 혼란을 겪는다.

➡️ **API Gateway + Orchestrator 구조**
API Gateway는 클라이언트 요청을 단일 진입점으로 받아 내부적으로 여러 서비스의 호출 흐름을 Orchestrator가 제어한다.
모든 작업이 완료되었을 때 하나의 응답으로 통합되며, 실패 시 일관된 보상 로직과 메시지를 사용자에게 반환할 수 있다.

참고)
API Gateway + 오케스트레이션 구조란?

- **여러 개의 마이크로서비스에 걸친 요청 흐름**을 사용자에게는 **하나의 단일 API처럼 제공**
- 내부적으로는 **복수 서비스에 순차적으로 요청을 보내고**, 그 결과를 조합하여 **응답의 일관성과 흐름 제어**를 담당

---

# ✏️3. 결론

## 📌3-1.  MSA 설계 효과

1. MSA 설계를 통해 콘서트 예약 시스템은 도메인별 책임을 명확하게 분리할 수 있고, 고부하 영역의 독립 배포 및 확장이 가능하다.
2. 또한 SAGA 패턴과 이벤트 기반 구조를 통해 트랜잭션 분리로 인한 문제를 구조적으로 해결할 수 있는 기반을 마련한다.
3. 이로써 시스템은 **확장성, 장애 격리, 배포 효율성, 트랜잭션 안정성** 측면에서 개선될 수 있다.

## 📌 3-2. 보완 사항

- **보상 트랜잭션의 복잡성**: SAGA 설계 및 테스트 자동화 필요
- **이벤트 중복/실패 처리**: Idempotency 및 재처리 체계 강화
- **운영 모니터링**: 분산 트레이싱 및 로그 집계 시스템 필요
- **보안 체계 정교화**: 서비스 간 인증/인가 강화

[MSA 셜계 보고서 notion](https://www.notion.so/teamsparta/8-Transaction-Diagnosis-MSA-1f92dc3ef51480f6920df959e64ec3a5#feb95fc05a374562b82ceb61eff151e7)
