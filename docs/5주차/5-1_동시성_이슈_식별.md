# 🎟️ 동시성 이슈 보고서

## 동시성 이슈 발생 지점 선별
- **좌석 선점(예약)**
- **유저 포인트 잔액**

---

# 1. 문제 식별 - 좌석 선점(예약)

### 개요

본 애플리케이션은 다수의 사용자가 콘서트 좌석을 예약할 수 있는 시스템이다. 동시에 여러 사용자가 동일한 좌석을 예약하려는 상황이 발생할 수 있으며, 이러한 경우 **동시성 제어가 적절하지 않으면 동일 좌석이 중복 예약**되는 문제가 발생할 수 있다.

### 발생한 이슈
동일한 유저가 동시에 여러 번 좌석 점유 요청을 보내는 경우, 트랜잭션 내에서 좌석 상태를 조회하고 점유하는 과정에서 동시성 문제가 발생할 수 있다.
이 경우, 여러 스레드가 해당 좌석 상태를 동시에 조회하고 업데이트하려 할 때, Race Condition이 발생할 가능성이 있다.
아래는 3개의 스레드가 동시에 동일한 좌석을 예약 요청한 테스트 코드이다.

```java
  @DisplayName("동일 좌석 동시 예약 요청 시 하나만 성공해야 한다.")
  @Test
  void testConcurrencyBookingSeatTest() throws InterruptedException {
    int threadCount = 3;
    ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
    CountDownLatch latch = new CountDownLatch(threadCount);

    //future로 비동기 작업 받을 수 있게 처리
    List<Future<ResponseMessage<BookingResponse>>> results = new ArrayList<>();

    for (int i = 0; i < threadCount; i++) {
        Future<ResponseMessage<BookingResponse>> result = executorService.submit(() -> {
            try {
                return bookingService.bookingSeat(bookingRequest);
            } catch (Exception e) {
                return ResponseMessage.error(500, e.getMessage());
            } finally {
                latch.countDown();
            }
        });
        results.add(result);
    }


      latch.await(); // 모든 스레드 완료까지 대기

      long successCount = results.stream()
              .filter(future -> {
                  try {
                      return future.get().getStatus() == 200;
                  } catch (Exception e) {
                      return false;
                  }
              })
              .count();

      long failCount = results.stream()
              .filter(future -> {
                  try {
                      return future.get().getStatus() != 200;
                  } catch (Exception e) {
                      return true;
                  }
              })
              .count();

      System.out.println("성공한 예약 요청 수: " + successCount);
      System.out.println("실패한 예약 요청 수: " + failCount);

      // 기대: 성공 1건
      assertEquals(1, successCount);
  }
```

**테스트 결과:**

- ✅ 성공한 예약 요청 수: 2
- ❌ 실패한 예약 요청 수: 1

---

### 기대 결과 vs 실제 결과

| 항목 | 기대값 | 실제값 |
|------|--------|--------|
| 성공 요청 수 | 1 | 2 |
| 실패 요청 수 | 2 | 1 |
| 좌석 중복 예약 여부 | 없음 | 있음 |


📌 왜 3개 모두 성공하지 못했는지?

| 이유 | 설명 | 
|------|--------|
| Race Condition | 3개의 스레드가 동시에 실행되며 모두 조건을 통과함 |
| 타이밍 차이 | 그 중 2개가 더 빨리 저장을 마쳤고, 1개는 늦게 시도함 |
| 동시성 제어 없음 |락이 없으니 트랜잭션 간 데이터 충돌을 감지 못함|
| 결과 | 2개는 성공, 1개는 실패 → 의도한 동작이 아님! |


---
## 문제 분석

### 코드 흐름 요약

1. **Seat 조회**: `concertId`와 `seatNum`을 기준으로 좌석을 조회합니다.
2. **예약 가능 여부 확인**: `booking.isAvailableBooking()`을 통해 예약 가능한 좌석인지 확인합니다.
3. **좌석 상태 변경**: 예약이 가능하다면, 좌석 상태를 `OCCUPIED`로 변경합니다.
4. **예약 처리**: `bookingRepository.save()`를 통해 예약 정보를 저장합니다.

```java
Seat seat = seatRepository.findByConcertSeat_Concert_ConcertIdAndSeatNum(bookingRequest.getConcertId(), bookingRequest.getSeatNum())
        .orElseThrow(() -> new EntityNotFoundException("해당 좌석을 찾을 수 없습니다."));

// 2. Booking 도메인 객체 생성
Booking booking = new Booking(concert, bookingRequest.getSeatNum(), user);

// 3. 예약 가능 여부 확인
//  booking의 seatNum의 좌석 점유 여부 체크
if (!booking.isAvailableBooking()) {
return ResponseMessage.error(500, "선택 좌석은 예약 불가능한 좌석입니다.");

} else {
        //좌석 점유 처리
        seat.setSeatStatus(SeatStatus.OCCUPIED);
    seatRepository.save(seat);

// booking 예약 처리
    bookingRepository.save(booking);
}

```
Seat 조회 → 예약 가능 여부 판단 → 상태 변경 → 저장 순으로 동작

이 로직은 트랜잭션으로 묶여 있으나, 조회와 저장 사이의 타이밍 간격에서 Race Condition이 발생할 수 있다.

---

### 이슈 발생 원인

- 여러 스레드가 동시에 동일한 Seat 엔티티를 조회
- 각각 상태가 AVAILABLE인 것을 확인하고 조건을 통과
- 거의 동시에 상태를 OCCUPIED로 변경하고 저장
- 그 결과, 여러 건의 예약이 성공해버리는 중복 예약 발생

특히 하나의 요청은 다른 요청보다 늦게 커밋되면서, 이미 OCCUPIED가 된 좌석을 보고 실패한 것으로 추정된다.
이 과정에서 Race Condition이 발생하고, 이는 동시성 문제가 발생한다.


---

### 동시성 이슈 해결 방안


---

# 2. 문제 식별 - 유저 포인트 잔액

### 개요
본 애플리케이션은 유저가 포인트를 충전할 수 있는 기능을 제공한다. 유저가 포인트를 충전하려고 할 때, 트랜잭션 내에서 포인트 잔액을 조회하고 업데이트하는 작업이 이루어진다. 하지만, 동일한 유저가 동시에 여러 번 포인트 충전 요청을 보낼 경우, 동시성 문제가 발생할 수 있다. 특히, 중복된 요청이 있을 경우, 여러 스레드가 동시에 같은 유저의 포인트를 수정하려 할 때, 포인트가 중복으로 충전되는 문제가 발생할 수 있다.

### 발생한 이슈
동일한 유저가 동시에 여러 번 포인트 충전 요청을 보내는 경우, 트랜잭션 내에서 포인트를 조회하고 충전하는 과정에서 동시성 문제가 발생할 수 있다. 이 경우, 여러 스레드가 같은 유저의 포인트 잔액을 동시에 조회하고 업데이트하려 할 때, Race Condition이 발생할 가능성이 있다. 특히, 하나의 스레드가 포인트를 조회하고 업데이트한 후, 다른 스레드도 동일한 정보를 조회하여 중복된 포인트 충전을 진행하는 상황이 발생할 수 있다.

### 예시 시나리오:
1. 유저 A가 100,000포인트를 충전하려는 요청을 보낸다.
2. 동시에 네트워크 문제나 UI 지연으로 같은 요청이 두 번 서버에 도달한다.
3. 두 요청이 거의 동시에 처리되며, 포인트 잔액을 중복으로 증가시키게 된다.

```java
@DisplayName("동일 유저에 대해 동시 포인트 충전 요청 시 하나만 성공해야 한다.")
@Test
void testConcurrencyChargePointTest() throws InterruptedException {
    int threadCount = 3;
    ExecutorService executorService = Executors.newFixedThreadPool(threadCount);
    CountDownLatch latch = new CountDownLatch(threadCount);

    PointChargeRequest pointChargeRequest = new PointChargeRequest(savedUserId, 100000L);
    
    List<Future<ResponseMessage<PointResponse>>> results = new ArrayList<>();
    
    for (int i = 0; i < threadCount; i++) {
        Future<ResponseMessage<PointResponse>> result = executorService.submit(() -> {
            try {
                return pointService.chargePoint(pointChargeRequest);
            } catch (Exception e) {
                return ResponseMessage.error(500, e.getMessage());
            } finally {
                latch.countDown();
            }
        });
        results.add(result);
    }
    
    latch.await();
    
    long successCount = results.stream()
            .filter(future -> {
                try {
                    return future.get().getStatus() == 200;
                } catch (Exception e) {
                    return false;
                }
            })
            .count();
    
    long failCount = results.stream()
            .filter(future -> {
                try {
                    return future.get().getStatus() != 200;
                } catch (Exception e) {
                    return true;
                }
            })
            .count();
    
    System.out.println("성공한 포인트 충전 요청 수: " + successCount);
    System.out.println("실패한 포인트 충전 요청 수: " + failCount);
    
    // 기대: 충전 성공 1건, 실패 2건
    assertEquals(1, successCount);  // 중복 충전이 발생하지 않도록 1번만 성공해야 함
}
```
**테스트 결과:**

- 락 처리 하지 않은 경우 결과
  ![img.png](포인트충전_락x.png)

---

### 기대 결과 vs 실제 결과

| 항목        | 기대값 | 실제값 |
|-----------|-----|-----|
| 성공 요청 수   | 1   | 10  |
| 실패 요청 수   | 0   | 0   |
| 중복 포인트 충전 | 없음  | 있음  |

---

## 문제 분석

### 코드 흐름 요약
현재의 포인트 충전 로직에서는 다음과 같은 순서로 작업이 처리된다:
1. 포인트 조회: pointRepository.findById(userId)를 통해 유저의 현재 포인트 잔액을 조회.
2. 포인트 충전: chargePoint() 메서드가 호출되어 포인트 잔액을 증가시킴.
3. 포인트 저장: 변경된 포인트 잔액을 pointRepository.save(point)를 통해 저장.

이 로직에서는 조회 후 업데이트가 이루어지며, 트랜잭션으로 묶여 있지만, 포인트 조회와 업데이트 사이에 다른 스레드가 개입할 수 있다. 
여러 스레드가 동시에 동일한 유저에 대해 포인트를 조회하고 업데이트하면, 중복된 충전이 발생할 수 있다.

```java
@Override
@Transactional
public ResponseMessage<PointResponse> chargePoint(PointChargeRequest pointChargeRequest) {

    Point point = pointRepository.findById(pointChargeRequest.getUserId())
            .orElseThrow(() -> new EntityNotFoundException("포인트 정보가 없습니다."));
    
    //충전 호출
    point.chargePoint(pointChargeRequest);
    
    //충전 저장
    pointRepository.save(point);
    
    PointResponse pointResponse = PointResponse.builder()
            .pointBalance(point.getPointBalance())
            .build();
    
    return ResponseMessage.success("포인트가 정상적으로 충전됐습니다.", pointResponse);
}
```

### 이슈 발생 원인
1. 동시성 문제: 여러 스레드가 동시에 **pointRepository.findById()**로 포인트를 조회하고, chargePoint() 메서드를 호출하여 포인트를 수정하려 시도.
2. Race Condition: 두 스레드가 거의 동시에 포인트 잔액을 증가시켜, 포인트가 중복으로 충전되는 현상이 발생.
3. 트랜잭션 관리 부족: 비록 트랜잭션 내에서 작업을 처리하지만, 동일 유저에 대한 포인트 충전 작업이 중복되도록 막는 제어가 부족하다.

---

## 동시성 이슈 해결 방안

### AS-IS

| 구분        | 내용                            | 
|-----------|-------------------------------|
| 트랜잭션 관리	  | 있음 (@Transactional)           |
| 동시성 제어	   | 없음                            | 
| 발생 가능 문제	   | 중복 충전, 잔액 불일치, Race Condition 
|


### TO-BE (낙관전 락 vs 비관적 락)

1. **낙관적 락 적용**
  - Point 엔티티에 @Version 필드 추가
  - JPA가 자동으로 충돌 시 OptimisticLockException 발생

```java
@Entity
public class Point {

    @Id
    private Long userId;

    @OneToOne(fetch = FetchType.LAZY)
    @MapsId
    @JoinColumn(name = "user_id", nullable = false, unique = true)
    private User user;


    @Schema(description = "포인트 잔액", example = "10000")
    @JsonProperty("pointBalance")
    private Long pointBalance;
    
    @Version
    private Long version; // 버전 관리 위해 version 추가
}
```
#### 적용 결과
![img_1.png](포인트충전_낙관적락.png)

```java
//낙관적 락 반영 메서드
@Override
public ResponseMessage<PointResponse> chargePointWithLock(PointChargeRequest pointChargeRequest) {
  try {
    return chargePoint(pointChargeRequest);

  } catch (ObjectOptimisticLockingFailureException e) {
    log.error("충전 실패: Optimistic Lock 예외 발생", e);
    throw e;
  }
}

/**
 * @description 유저의 포인트를 충전한다.
 * @param pointChargeRequest
 * @return
 */
@Override
@Transactional(propagation = Propagation.REQUIRES_NEW)
public ResponseMessage<PointResponse> chargePoint(PointChargeRequest pointChargeRequest) {

  //현재 잔액 조회
  Point point = pointRepository.findById(pointChargeRequest.getUserId())
          .orElseThrow(() -> new EntityNotFoundException("포인트 정보가 없습니다."));

  if (point.isCharged()) {
    throw new IllegalStateException("이미 충전된 요청입니다.");
  }

  //충전 호출
  point.chargePoint(pointChargeRequest);

  //충전 저장
  pointRepository.save(point);

  point.setCharged(true);

  PointResponse pointResponse = PointResponse.builder()
          .pointBalance(point.getPointBalance())
          .build();

  return ResponseMessage.success("포인트가 정상적으로 충전됐습니다.", pointResponse);
}
}
```

#### 장단점

- 장점
  - 락을 직접 걸지 않아 성능 저하가 적다.
  - 대부분의 경우 충돌 없이 빠르게 처리됨.
- 단점
  - 충돌 발생 시 예외 발생 -> 재시도 로직 필요
  - 반복 요청이 많을 경우 처리 실패율 증가 가능


2. **비관적 락 적용**
- 조회 시 Pessimistic Lock 걸기
- 비관적 락의 경우 동시 요청은 처리중인 스레드를 제외하고 락을 걸고, 대기한 후에 순차적으로 처리되므로 모든 요청이 성공한다. 포인트 충전의 경우 모든 요청이 성공하면 안되고 중복 방지를 위한 락 처리를 해야하므로 비관적 락을 사용할 경우엔 '이미 충전된 요청'임을 알 수 있도록 예외처리를 추가한다.

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Point p WHERE p.userId = :userId")
Optional<Point> findByUserIdWithLock(@Param("userId") Long userId);

@Transactional
public ResponseMessage<PointResponse> chargePointWithPessimisticLock(PointChargeRequest pointChargeRequest) {

  // 비관적 락을 사용하여 현재 포인트 정보 가져오기
  Point point = pointRepository.findByUserIdForUpdate(pointChargeRequest.getUserId())
          .orElseThrow(() -> new EntityNotFoundException("포인트 정보가 없습니다."));

  // 이미 충전된 요청일 경우 예외처리
  if (point.isCharged()) { // 충전 상태를 체크하는 로직
    throw new IllegalStateException("이미 충전된 요청입니다.");
  }

  // 충전 호출
  point.chargePoint(pointChargeRequest);

  // 충전 상태를 업데이트 (중복 충전을 방지하기 위해 플래그 업데이트)
  point.setCharged(true);

  // 포인트 정보 저장
  pointRepository.save(point);

  // 충전 후 응답 반환
  PointResponse pointResponse = PointResponse.builder()
          .pointBalance(point.getPointBalance())
          .build();

  return ResponseMessage.success("포인트가 정상적으로 충전됐습니다.", pointResponse);
}
```

#### 적용 결과

![img_2.png](포인트충전_비관적락.png)
  
#### 장단점

- 장점
    - 한 번에 하나의 트랜잭션만 데이터 수정 가능 → 충돌 없음
    - 충돌 재시도 로직 불필요 → 처리 간결
- 단점
    - 트랜잭션 대기 시간 발생 → 응답 지연
    - Deadlock 가능성 → 락 범위 및 순서 조심해야 함
    - 모든 요청이 성공하므로 이를 방지하기 위한 추가 로직 필요
---

### 3. AS-IS / TO-BE 비교

| 항목                | AS-IS (기존)                       | TO-BE (Optimistic)                                 | TO-BE (Pessimistic)                              |
|---------------------|------------------------------------|----------------------------------------------------|--------------------------------------------------|
| 동시성 제어         | ❌ 없음                            | ✅ 버전 기반 제어                                   | ✅ DB 락 기반 제어                                 |
| 처리 방식           | 병렬 → 충돌 가능                   | 병렬 → 충돌 시 예외 발생 → 재시도 필요              | 직렬 → 대기 발생 가능                             |
| 충돌 처리           | ❌ 미처리                          | 🔄 재시도 로직 필요                                 | 🚫 충돌 없음                                      |
| 성능                | 🔼 빠름 (충돌 시 위험)              | 🔼 충돌 없으면 빠름                                 | 🔽 느릴 수 있으나 안정적                          |
| 구현 난이도         | ✅ 단순                            | 🔄 재시도 로직 필요                                 | 🔧 락 범위/순서 설계 필요                         |
| 데이터 정합성       | ❌ 불안정                          | ⚠️ 충돌 시 실패 가능                                | ✅ 강력한 정합성 보장                             |

---
### 어떤 전략이 더 타당한가?

#### 🔍 포인트 충전 기능의 특성

| 요소                  | 내용                                           |
|-----------------------|------------------------------------------------|
| 중요도                | 💥 유저 자산에 관련된 중요한 기능              |
| 충돌 가능성           | 중복 요청 등으로 인해 충돌 발생 가능           |
| 데이터 정합성 요구 수준 | 매우 높음                                      |
| 사용자 기대           | 1회 요청 시 정확한 포인트 충전 보장            |
| 트래픽/성능 요구       | 상대적으로 낮음 (비관적 락 적용에도 부담 적음) |

✅ 결론: 비관적 락이 더 타당하다고 볼 수 있으나, **낙관적 락**으로 결정한다!

포인트 충전의 경우
- 한 유저가 동시에 여러 요청 보낼 가능성은 낮다. 그러므로 굳이 비관적 락을 사용해서 성능 저하시킬 필요 없다고 판단한다.
- 비관적락은 동시 요청 시, DB 락으로 순차적으로 처리 -> 모드 성공 처리시키는 것이다. 포인트 충전의 경우 한 요청만 처리되어야할 확률이 높으므로 낙관적 락으로 결정한다.
- 모든 요청을 성공시키면 안되므로 낙관적 락으로 결정한다.

---
## Lock 전략 개념 비교(참고)

🔒 DB Lock 전략 비교 및 적용 보고서

| 구분        | 낙관적 락 (Optimistic Lock) | 비관적 락 (Pessimistic Lock) |
|-----------|--------|-----|
| 기본 개념   | 충돌이 발생하지 않을 거라 낙관하고 처리. 충돌 발생 시 예외 발생 및 재시도 필요. | 충돌이 발생할 수 있다고 **가정(비관)**하고, 데이터를 읽는 시점에 락을 걸어 선점함.  |
| 적용 방식   | @Version 필드로 엔티티 버전을 관리. 트랜잭션 커밋 시 버전 비교. | JPA의 @Lock(LockModeType.PESSIMISTIC_WRITE) 등으로 SQL 레벨의 행 잠금(Lock) 수행. |
| 동시성 처리 방식   | 트랜잭션 간 충돌 시 OptimisticLockException 발생 → 재시도 필요 | 하나의 트랜잭션이 끝날 때까지 다른 트랜잭션은 대기 또는 차단 |
| 성능   | 충돌이 적은 경우 성능 우수 (락 X) | 트랜잭션 간 경쟁이 많을수록 성능 저하  |
| 구현 난이도   | 비교적 간단하지만, 충돌 재처리 로직 필요 | 쿼리와 트랜잭션 범위를 정확히 조절해야 하므로 상대적으로 구현 복잡  |
| 주로 사용하는 곳   | 읽기 많은 환경, 충돌 적고 빠른 응답이 중요한 경우 (ex. 조회 기반 UI)| 정합성 중요, 충돌 가능성이 높은 환경 (ex. 은행, 재고, 예약 시스템 등)  |


		
		
		
		
		
		