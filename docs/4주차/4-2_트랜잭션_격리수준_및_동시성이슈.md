# 1. 트랜잭션 격리 수준 및 동시성 이슈

##  📌 트랜잭션 격리 수준

### 트랜잭션 격리 수준이란?
- 트랜잭션이 동시에 실행될 때 데이터 일관성을 얼마나 보장할지 결정하는 수준.
- 격리 수준이 높을수록 일관성은 좋아지지만 성능은 떨어짐. 반대로 낮을수록 성능은 좋지만 동시성 문제가 생길 수  있음.

### 📊 트랜잭션 격리 수준 정리표

| 격리 수준           | Dirty Read | Non-Repeatable Read | Phantom Read | 성능     | 기본값 (MySQL) |
|--------------------|------------|----------------------|---------------|----------|----------------|
| Read Uncommitted   | ✅ 발생     | ✅ 발생               | ✅ 발생        | 🔥 빠름  | ❌              |
| Read Committed     | ❌ 차단     | ✅ 발생               | ✅ 발생        | 😀 좋음  | ❌              |
| Repeatable Read    | ❌ 차단     | ❌ 차단               | ✅ 발생        | 🙂 보통  | ✅ 기본값       |
| Serializable       | ❌ 차단     | ❌ 차단               | ❌ 차단        | 🐢 느림  | ❌              |

---
### 각 격리 수준 실험 내용
- Read Uncommitted : Drity Read 실험
  - 트랜잭션 A가 커밋 안 한 데이터를 트랜잭션 B가 읽는지 확인
- Read Committed
  - 트랜잭션 A에서 두 번 읽을 때, 중간에 B가 수정한 값이 보이는지 확인
- Repeatable Read
  - 트랜잭션 A에서 조건에 맞는 row를 조회한 뒤, 트랜잭션 B가 row 삽입 시 A에 영향을 미치는지 확인
- Serializable
  - 모든 동시성 이슈가 막히는지 확인(Lock 확인 포함)

### 각 격리 수준에서 발생할 수 있는 동시성 이슈 정리
- Dirty Read  
  커밋되지 않은 데이터를 다른 트랜잭션이 읽는 현상

- Non-Repeatable Read
  같은 데이터를 두 번 읽을 때, 중간에 값이 변경되어 다른 결과가 나오는 현상

- Phantom Read  
  조건에 맞는 데이터를 조회했을 때, 중간에 새로운 데이터가 추가되어 결과가 달라지는 현상


### 📌 참고
- MySQL(InnoDB)의 기본 격리 수준은 `Repeatable Read`
- 성능과 정합성은 트레이드오프 관계이므로 상황에 맞는 선택이 중요

---

## **Read Uncommitted : Drity Read 테스트**

## **목표**
- **Dirty Read**를 테스트하기 위해 **Read Uncommitted** 격리 수준을 사용하여 트랜잭션 간의 동시성 문제를 확인한다.
- 테스트는 두 개의 트랜잭션(A, B)을 동시에 실행하여, 트랜잭션 A가 커밋되지 않은 상태에서 트랜잭션 B가 데이터를 읽을 수 있는지 검증한다.

## **테스트 시나리오**

1. **트랜잭션 A**는 사용자의 포인트를 수정하고, 변경된 값은 커밋되지 않은 상태에서 2초 동안 대기한다.
2. **트랜잭션 B**는 트랜잭션 A가 시작된 후, A가 커밋되기 전에 해당 포인트를 읽고 변경된 값을 확인한다.
3. 트랜잭션 A가 커밋되기 전에 트랜잭션 B는 읽을 수 있는지 확인하여 **Dirty Read**가 발생했는지 확인한다.

## **테스트 흐름**
### 1. **Test Setup**
- **테스트용 데이터 준비**:
  - 테스트용 사용자(`User`)와 그에 연관된 포인트(`Point`)를 데이터베이스에 저장한다.
  - 트랜잭션 A에서 사용하는 사용자 ID(`savedUserId`)를 저장한다.

### 2. **트랜잭션 A: 포인트 수정**
- 트랜잭션 A는 **Read Uncommitted** 격리 수준에서 실행된다.
- 트랜잭션 A는 포인트를 100 증가시킨 후, 커밋되지 않은 상태로 2초 동안 대기한다.
- 트랜잭션 A가 커밋되기 전, 트랜잭션 B가 해당 포인트를 읽을 수 있는지 확인한다.

```java
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void transactionA(Long userId) throws InterruptedException {
    Point point = pointRepository.findById(userId)
            .orElseThrow(() -> new RuntimeException("포인트 정보가 없습니다."));
    
    point.setPointBalance(point.getPointBalance() + 10000);  // 포인트 증가
    pointRepository.save(point);  // 커밋되지 않은 상태로 수정

    System.out.println("📝 트랜잭션 A: 포인트 수정 완료 (커밋 전)");
    
    // 2초 대기 후 커밋
    Thread.sleep(2000);  

    System.out.println("✅ 트랜잭션 A 종료 (커밋)");
}

@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void transactionB(Long userId) {
    Point point = pointRepository.findById(userId)
            .orElseThrow(() -> new RuntimeException("포인트 정보가 없습니다."));
    
    System.out.println("👀 트랜잭션 B가 읽은 포인트 잔액: " + point.getPointBalance());
}
``` 

``` 
<최종 로그 결과>
📝 트랜잭션 A: 포인트 수정 완료 (커밋 전)
👀 트랜잭션 B가 읽은 포인트 잔액: 200,000  -> Dirty Read 발생!!  (의도는 205,000인데 MySQL( InnoDB)는 READ UNCOMMITTED 지정해도 내부적으로는 Dirty Read를 거의 허용하지 않음.)

✅ 트랜잭션 A 종료 (커밋)
``` 

---

## **Read Committed**
## **목표**
- **Dirty Read**가 발생하지 않음을 확인하기 위해 **Read Committed** 격리 수준을 사용하는 트랜잭션 간 동시성 테스트를 수행한다.
- 트랜잭션 A가 커밋되지 않은 상태에서 트랜잭션 B가 동일 데이터를 읽을 수 있는지를 확인하여 **Dirty Read 방지 여부**를 검증한다.

## **테스트 시나리오**

1. **트랜잭션 A**는 사용자 포인트를 수정한 후, **커밋하지 않고 2초간 대기**한다.
2. **트랜잭션 B**는 트랜잭션 A가 **커밋되기 전**, 동일 포인트 데이터를 조회한다.
3. 트랜잭션 B가 **변경된 데이터를 읽지 못하고**, 기존 데이터를 조회해야 테스트 성공으로 간주한다.

## **테스트 흐름**
### 1. **Test Setup**
- **테스트용 데이터 준비**:
  - 테스트용 User와 Point를 생성한다.
  - 테스트 메서드 시작 전 DB에 데이터 저장 및 커밋 완료

### 2. **트랜잭션 A: 포인트 수정**
- 격리 수준: `READ_COMMITTED`
- 동작 내용:
  - 포인트 `+5000` 증가 (`205000`)
  - DB에 커밋은 하지 않음
  - 2초간 대기하여 트랜잭션 B가 조회할 수 있도록 유도

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void readCommittedTransactionA(Long userId) throws InterruptedException {
  // 포인트 조회
  Point point = pointRepository.findById(userId)
          .orElseThrow(() -> new RuntimeException("포인트 정보가 없습니다."));

  point.setPointBalance(point.getPointBalance() + 5000L);  // 포인트 증가
  pointRepository.save(point);  // 커밋되지 않은 상태로 수정

  System.out.println("###### 트랜잭션 A: 포인트 수정 완료 (커밋 전)");
  // 2초 대기 후 커밋
  Thread.sleep(2000); // B가 이 사이에 읽도록 유도
  System.out.println("###### 트랜잭션 A 종료 (커밋)");
}

@Transactional(isolation = Isolation.READ_COMMITTED)
public void readCommittedTransactionB(Long userId) {
  // 트랜잭션 A에서 커밋된 데이터를 읽을 수 있는지 확인
  Point point = pointRepository.findById(userId)
          .orElseThrow(() -> new RuntimeException("포인트 정보가 없습니다."));

  System.out.println("###### 트랜잭션 B가 읽은 포인트 잔액: " + point.getPointBalance());
}
``` 

``` 
<최종 로그 결과>
📝 트랜잭션 A: 포인트 수정 완료 (커밋 전)
👀 트랜잭션 B가 읽은 포인트 잔액: 200,000 -> A트랜잭션이 커밋되기 전 데이터를 조회함.
✅ 트랜잭션 A 종료 (커밋)
``` 

---

## **Repeatable Read**
## **목표**
- 동일 트랜잭션 내에서 동일한 데이터를 여러 번 조회할 때 **일관된 결과가 반환되는지 검증**한다.
- 트랜잭션 A가 포인트 데이터를 두 번 조회하고, 그 사이 트랜잭션 B가 값을 수정하는 시나리오를 통해 **Repeatable Read** 격리 수준의 특성을 테스트한다.

## **테스트 시나리오**

1. **트랜잭션 A**는 포인트를 한 번 조회한 뒤, **2초간 대기** 후 다시 같은 데이터를 조회한다.
2. **트랜잭션 B**는 A의 첫 조회 이후 데이터를 **수정하고 커밋**한다.
3. A의 두 번째 조회 시 값이 **처음과 동일하면 Repeatable Read 보장**, **달라졌다면 깨짐**.

## **테스트 흐름**
### 1. **Test Setup**

- **초기 데이터**
  - 포인트 잔액: `200000`
  - 사용자 ID: `savedUserId`에 저장
  - 트랜잭션 A와 B는 해당 사용자 ID로 조회 및 수정

### 2. **트랜잭션 A: 두 번 조회**

- 격리 수준: `REPEATABLE_READ`
- 수행 내용:
  1. 포인트 **첫 조회**
  2. 트랜잭션 B 실행을 유도 (`CountDownLatch`)
  3. 2초 후 **두 번째 조회**
  4. 두 조회 결과 비교

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void repeatableReadTransactionA(Long userId, CountDownLatch latch) throws InterruptedException {
  Point point1 = pointRepository.findById(userId)
          .orElseThrow(() -> new RuntimeException("포인트 정보가 없습니다."));

  System.out.println("🔁 [A] 첫 조회: " + point1.getPointBalance());
  latch.countDown(); // B 실행 시작 알림

  Thread.sleep(2000); // B가 중간에 수정하도록 대기

  Point point2 = pointRepository.findById(userId)
          .orElseThrow(() -> new RuntimeException("포인트 정보가 없습니다."));
  System.out.println("🔁 [A] 두 번째 조회: " + point2.getPointBalance());

  if (point1.getPointBalance().equals(point2.getPointBalance())) {
    System.out.println("✅ Repeatable Read 보장됨: 두 조회 결과 동일");
  } else {
    System.out.println("❌ Repeatable Read 깨짐: 값이 달라짐");
  }
}

@Transactional
public void repeatableReadTransactionB(Long userId) {
  Point point = pointRepository.findById(userId)
          .orElseThrow(() -> new RuntimeException("포인트 정보가 없습니다."));

  point.setPointBalance(point.getPointBalance() + 10000);
  pointRepository.save(point);
  pointRepository.flush();
  System.out.println("✏️ [B] 포인트 수정 및 커밋 완료");
}
``` 

``` 
<최종 로그 결과>
[A] 첫 조회: 200000
[B] 포인트 수정 및 커밋 완료
[A] 두 번째 조회: 200000
Repeatable Read 보장됨: 두 조회 결과 동일
``` 

---

## **Serializable**


---



