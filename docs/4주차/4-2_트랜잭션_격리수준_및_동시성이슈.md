# 1. 트랜잭션 격리 수준 및 동시성 이슈

##  📌 트랜잭션 격리 수준

### 트랜잭션 격리 수준이란?
- 트랜잭션이 동시에 실행될 때 데이터 일관성을 얼마나 보장할지 결정하는 수준.
- 격리 수준이 높을수록 일관성은 좋아지지만 성능은 떨어짐. 반대로 낮을수록 성능은 좋지만 동시성 문제가 생길 수  있음.

### 📊 트랜잭션 격리 수준 정리표

| 격리 수준           | Dirty Read | Non-Repeatable Read | Phantom Read | 성능     | 기본값 (MySQL) |
|--------------------|------------|----------------------|---------------|----------|----------------|
| Read Uncommitted   | ✅ 발생     | ✅ 발생               | ✅ 발생        | 🔥 빠름  | ❌              |
| Read Committed     | ❌ 차단     | ✅ 발생               | ✅ 발생        | 😀 좋음  | ❌              |
| Repeatable Read    | ❌ 차단     | ❌ 차단               | ✅ 발생        | 🙂 보통  | ✅ 기본값       |
| Serializable       | ❌ 차단     | ❌ 차단               | ❌ 차단        | 🐢 느림  | ❌              |

---
### 각 격리 수준 실험 내용
- Read Uncommitted : Drity Read 실험
  - 트랜잭션 A가 커밋 안 한 데이터를 트랜잭션 B가 읽는지 확인
- Read Committed
  - 트랜잭션 A에서 두 번 읽을 때, 중간에 B가 수정한 값이 보이는지 확인
- Repeatable Read
  - 트랜잭션 A에서 조건에 맞는 row를 조회한 뒤, 트랜잭션 B가 row 삽입 시 A에 영향을 미치는지 확인
- Serializable
  - 모든 동시성 이슈가 막히는지 확인(Lock 확인 포함)

### 각 격리 수준에서 발생할 수 있는 동시성 이슈 정리
- Dirty Read  
  커밋되지 않은 데이터를 다른 트랜잭션이 읽는 현상

- Non-Repeatable Read
  같은 데이터를 두 번 읽을 때, 중간에 값이 변경되어 다른 결과가 나오는 현상

- Phantom Read  
  조건에 맞는 데이터를 조회했을 때, 중간에 새로운 데이터가 추가되어 결과가 달라지는 현상


### 📌 참고
- MySQL(InnoDB)의 기본 격리 수준은 `Repeatable Read`
- 성능과 정합성은 트레이드오프 관계이므로 상황에 맞는 선택이 중요

---

## **Read Uncommitted : Drity Read 테스트**

## **목표**
- **Dirty Read**를 테스트하기 위해 **Read Uncommitted** 격리 수준을 사용하여 트랜잭션 간의 동시성 문제를 확인한다.
- 테스트는 두 개의 트랜잭션(A, B)을 동시에 실행하여, 트랜잭션 A가 커밋되지 않은 상태에서 트랜잭션 B가 데이터를 읽을 수 있는지 검증한다.

## **테스트 시나리오**

1. **트랜잭션 A**는 사용자의 포인트를 수정하고, 변경된 값은 커밋되지 않은 상태에서 2초 동안 대기한다.
2. **트랜잭션 B**는 트랜잭션 A가 시작된 후, A가 커밋되기 전에 해당 포인트를 읽고 변경된 값을 확인한다.
3. 트랜잭션 A가 커밋되기 전에 트랜잭션 B는 읽을 수 있는지 확인하여 **Dirty Read**가 발생했는지 확인한다.

## **테스트 흐름**
### 1. **Test Setup**
- **테스트용 데이터 준비**:
  - 테스트용 사용자(`User`)와 그에 연관된 포인트(`Point`)를 데이터베이스에 저장한다.
  - 트랜잭션 A에서 사용하는 사용자 ID(`savedUserId`)를 저장한다.

### 2. **트랜잭션 A: 포인트 수정**
- 트랜잭션 A는 **Read Uncommitted** 격리 수준에서 실행된다.
- 트랜잭션 A는 포인트를 100 증가시킨 후, 커밋되지 않은 상태로 2초 동안 대기한다.
- 트랜잭션 A가 커밋되기 전, 트랜잭션 B가 해당 포인트를 읽을 수 있는지 확인한다.

```java
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void transactionA(Long userId) throws InterruptedException {
    Point point = pointRepository.findById(userId)
            .orElseThrow(() -> new RuntimeException("포인트 정보가 없습니다."));
    
    point.setPointBalance(point.getPointBalance() + 10000);  // 포인트 증가
    pointRepository.save(point);  // 커밋되지 않은 상태로 수정

    System.out.println("📝 트랜잭션 A: 포인트 수정 완료 (커밋 전)");
    
    // 2초 대기 후 커밋
    Thread.sleep(2000);  

    System.out.println("✅ 트랜잭션 A 종료 (커밋)");
}

@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void transactionB(Long userId) {
    Point point = pointRepository.findById(userId)
            .orElseThrow(() -> new RuntimeException("포인트 정보가 없습니다."));
    
    System.out.println("👀 트랜잭션 B가 읽은 포인트 잔액: " + point.getPointBalance());
}
``` 
``` 
<최종 로그 결과>
📝 트랜잭션 A: 포인트 수정 완료 (커밋 전)
👀 트랜잭션 B가 읽은 포인트 잔액: 200000  -> Dirty Read 발생!!
✅ 트랜잭션 A 종료 (커밋)
``` 

---

## **Read Committed**
## **목표**


---

## **Repeatable Read**


---


## **Serializable**


---



